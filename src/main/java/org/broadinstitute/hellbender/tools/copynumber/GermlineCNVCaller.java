package org.broadinstitute.hellbender.tools.copynumber;

import htsjdk.samtools.SAMSequenceDictionary;
import org.broadinstitute.barclay.argparser.Advanced;
import org.broadinstitute.barclay.argparser.Argument;
import org.broadinstitute.barclay.argparser.ArgumentCollection;
import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;
import org.broadinstitute.barclay.help.DocumentedFeature;
import org.broadinstitute.hellbender.cmdline.CommandLineProgram;
import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;
import org.broadinstitute.hellbender.cmdline.argumentcollections.IntervalArgumentCollection;
import org.broadinstitute.hellbender.cmdline.argumentcollections.OptionalIntervalArgumentCollection;
import org.broadinstitute.hellbender.cmdline.programgroups.CopyNumberProgramGroup;
import org.broadinstitute.hellbender.exceptions.UserException;
import org.broadinstitute.hellbender.tools.copynumber.annotation.AnnotatedIntervalCollection;
import org.broadinstitute.hellbender.tools.copynumber.coverage.readcount.SimpleCountCollection;
import org.broadinstitute.hellbender.tools.copynumber.formats.CopyNumberArgumentValidationUtils;
import org.broadinstitute.hellbender.tools.copynumber.formats.CopyNumberStandardArgument;
import org.broadinstitute.hellbender.tools.copynumber.formats.collections.SimpleIntervalCollection;
import org.broadinstitute.hellbender.utils.SimpleInterval;
import org.broadinstitute.hellbender.utils.Utils;
import org.broadinstitute.hellbender.utils.io.IOUtils;
import org.broadinstitute.hellbender.utils.io.Resource;
import org.broadinstitute.hellbender.utils.python.PythonScriptExecutor;
import org.broadinstitute.hellbender.utils.reference.ReferenceUtils;

import java.io.File;
import java.io.Serializable;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Denoise and call copy-number variants in germline samples given their fragment counts and the corresponding output
 * of {@link DetermineGermlineContigPloidy}.
 * The former should be either HDF5 or TSV count files generated by {@link CollectFragmentCounts}.
 *
 *  <p>
 *      If multiple samples are input, then the output is a model directory (which can be used for subsequently denoising
 *      individual samples, see below), as well as directories containing files that specify calls and
 *      sample-level model parameters for each sample.  The latter should be used as input to
 *      {@link //TODO PostprocessGermlineCNVCalls}.
 *      Depending on available memory, it may be necessary to run over a subset of the intervals,
 *      which can be specified by -L and must be present in all of the count files.
 *  </p>
 *
 *  <p>
 *      If a single sample and a model directory are input, then only files that specify calls and sample-level
 *      model parameters for that sample are output.  Again, these should be used as input to
 *      {@link //TODO PostprocessGermlineCNVCalls}.
 *      Only the modeled intervals are used and must be present in all of the count files; no intervals
 *      should be specified via -L.
 *  </p>
 *
 * TODO Mehrtash can add documentation here
 *
 * <h3>Examples</h3>
 *
 * <pre>
 * gatk-launch --javaOptions "-Xmx4g" GermlineCNVCaller \
 *   -L intervals.interval_list \
 *   --input normal_1.counts.hdf5 \
 *   --input normal_2.counts.hdf5 \
 *   ... \
 *   --output output_dir \
 *   --outputPrefix normal_cohort
 * </pre>
 *
 * <pre>
 * gatk-launch --javaOptions "-Xmx4g" GermlineCNVCaller \
 *   -L intervals.interval_list \
 *   --input normal_1.counts.hdf5 \
 *   --model normal_cohort.ploidyModel.tsv \
 *   ... \
 *   --output output_dir \
 *   --outputPrefix normal_1
 * </pre>
 *
 * @author Mehrtash Babadi &lt;mehrtash@broadinstitute.org&gt;
 * @author Samuel Lee &lt;slee@broadinstitute.org&gt;
 */
@CommandLineProgramProperties(
        summary = "Denoise and call copy-number variants in germline samples given their fragment counts and the output of DetermineGermlineContigPloidy.",
        oneLineSummary = "Denoise and call copy-number variants in germline samples given their fragment counts and the output of DetermineGermlineContigPloidy.",
        programGroup = CopyNumberProgramGroup.class
)
@DocumentedFeature
public final class GermlineCNVCaller extends CommandLineProgram {
    private enum Mode {
        COHORT, CASE
    }

    public static final String COHORT_DENOISING_CALLING_PYTHON_SCRIPT = "cohort_denoising_calling.py";
    public static final String CASE_SAMPLE_CALLING_PYTHON_SCRIPT = "case_denoising_calling.py";

    public static final String INPUT_MODEL_INTERVAL_FILE = "interval_list.tsv";     //name of the interval file output by the python code in the model directory

    public static final String MODEL_PATH_SUFFIX = "-model";
    public static final String CALLS_PATH_SUFFIX = "-calls";

    public static final String CONTIG_PLOIDY_CALLS_DIRECTORY_LONG_NAME = "contigPloidyCalls";
    public static final String CONTIG_PLOIDY_CALLS_DIRECTORY_SHORT_NAME = "ploidyCalls";

    @Argument(
            doc = "Input read-count files containing integer read counts in genomic intervals for all samples.  " +
                    "All intervals specified via -L must be contained; " +
                    "if none are specified, then intervals must be identical and in the same order for all samples.  " +
                    "If only a single sample is specified, an input denoising-model directory must also be specified.  ",
            fullName = StandardArgumentDefinitions.INPUT_LONG_NAME,
            shortName = StandardArgumentDefinitions.INPUT_SHORT_NAME,
            minElements = 1
    )
    private List<File> inputReadCountFiles = new ArrayList<>();

    @Argument(
            doc = "Input contig-ploidy calls directory (output of DetermlineGermlineContigPloidy).",
            fullName = CONTIG_PLOIDY_CALLS_DIRECTORY_LONG_NAME,
            shortName = CONTIG_PLOIDY_CALLS_DIRECTORY_SHORT_NAME
    )
    private String inputContigPloidyCallsDir;

    @Argument(
            doc = "Input denoising-model directory.  If only a single sample is specified, this input is required.  " +
                    "If multiple samples are specified, a new model will be built using this input model to initialize.",
            fullName = CopyNumberStandardArgument.MODEL_LONG_NAME,
            shortName = CopyNumberStandardArgument.MODEL_SHORT_NAME,
            optional = true
    )
    private String inputModelDir = null;

    @Argument(
            doc = "Input annotated-interval file containing annotations for GC content in genomic intervals (output of AnnotateIntervals).  " +
                    "All intervals specified via -L must be contained.  " +
                    "If only a single sample is specified, this input should not be provided.",
            fullName = CopyNumberStandardArgument.ANNOTATED_INTERVALS_FILE_LONG_NAME,
            shortName = CopyNumberStandardArgument.ANNOTATED_INTERVALS_FILE_SHORT_NAME,
            optional = true
    )
    private File inputAnnotatedIntervalsFile = null;

    @Argument(
            doc = "Prefix for output filenames.",
            fullName =  CopyNumberStandardArgument.OUTPUT_PREFIX_LONG_NAME,
            shortName = CopyNumberStandardArgument.OUTPUT_PREFIX_SHORT_NAME
    )
    private String outputPrefix;

    @Argument(
            doc = "Output directory.",
            fullName =  StandardArgumentDefinitions.OUTPUT_LONG_NAME,
            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME
    )
    private String outputDir;

    @Argument(
            doc = "Use the given sequence dictionary as the master/canonical sequence dictionary.  Must be a .dict file.  " +
                    "Must be provided if intervals are specified via -L.",
            fullName = StandardArgumentDefinitions.SEQUENCE_DICTIONARY_NAME,
            shortName = StandardArgumentDefinitions.SEQUENCE_DICTIONARY_NAME,
            optional = true
    )
    private File sequenceDictionaryFile = null;

    @ArgumentCollection
    protected IntervalArgumentCollection intervalArgumentCollection = new OptionalIntervalArgumentCollection();

    @Advanced
    @ArgumentCollection
    private GermlineDenoisingArgumentCollection germlineDenoisingArgumentCollection = new GermlineDenoisingArgumentCollection();

    @Advanced
    @ArgumentCollection
    private GermlineCallingArgumentCollection germlineCallingArgumentCollection = new GermlineCallingArgumentCollection();

    private Mode mode;
    private LinkedHashSet<SimpleInterval> intervals;
    private File intervalsFile;

    @Override
    protected Object doWork() {
        setModeAndValidateArguments();

        //read in count files, validate they contain specified subset of intervals, and output count files for these intervals to temporary files
        final List<File> intervalSubsetReadCountFiles = writeIntervalSubsetReadCountFiles();

        //call python inference code
        final boolean pythonReturnCode = executeGermlineCNVCallerPythonScript(intervalSubsetReadCountFiles);

        if (!pythonReturnCode) {
            throw new UserException("Python return code was non-zero.");
        }

        logger.info("Germline denoising and CNV calling complete.");

        return "SUCCESS";
    }

    private void setModeAndValidateArguments() {
        inputReadCountFiles.forEach(IOUtils::canReadFile);

        if (inputModelDir != null) {
            Utils.validateArg(new File(inputModelDir).exists(),
                    String.format("Input denoising-model directory %s does not exist.", inputModelDir));
        }

        if (inputReadCountFiles.size() > 1) {
            logger.info("Multiple samples were provided, running in cohort mode...");
            mode = Mode.COHORT;

            Utils.validateArg(inputReadCountFiles.size() == new HashSet<>(inputReadCountFiles).size(),
                    "List of input read-count files cannot contain duplicates.");

            if (sequenceDictionaryFile != null && intervalArgumentCollection.intervalsSpecified()) {
                final SAMSequenceDictionary sequenceDictionary = ReferenceUtils.loadFastaDictionary(sequenceDictionaryFile);
                CopyNumberArgumentValidationUtils.validateIntervalArgumentCollection(intervalArgumentCollection);
                intervals = new LinkedHashSet<>(intervalArgumentCollection.getIntervals(sequenceDictionary));
            } else if (sequenceDictionaryFile == null && !intervalArgumentCollection.intervalsSpecified()) {
                intervals = getIntervalsFromFirstReadCountFile();
            } else {
                throw new UserException.BadInput("Invalid combination of inputs: Both sequence dictionary and intervals should be provided if only a subset of intervals is to be modeled, " +
                        "or neither should be provided if all intervals are to be modeled.");
            }

            if (inputAnnotatedIntervalsFile != null) {
                IOUtils.canReadFile(inputAnnotatedIntervalsFile);
                Utils.validateArg(new AnnotatedIntervalCollection(inputAnnotatedIntervalsFile).getIntervals().containsAll(intervals),
                        "Annotated-intervals file does not contain all specified intervals.");
            }

            intervalsFile = IOUtils.createTempFile("intervals", ".tsv");    //in cohort mode, intervals are specified via -L; we write them to a temporary file
            if (inputAnnotatedIntervalsFile == null) {
                new SimpleIntervalCollection(new ArrayList<>(intervals)).write(intervalsFile);
            } else {
                logger.info("Annotated intervals were provided; explicit GC-bias correction will be performed...");
                final AnnotatedIntervalCollection inputAnnotatedIntervals = new AnnotatedIntervalCollection(inputAnnotatedIntervalsFile);
                final AnnotatedIntervalCollection subsetAnnotatedIntervals = new AnnotatedIntervalCollection(
                        inputAnnotatedIntervals.getRecords().stream()
                                .filter(i -> intervals.contains(i.getInterval()))
                                .collect(Collectors.toList()));
                subsetAnnotatedIntervals.write(intervalsFile);
            }
        } else {
            logger.info("A single sample was provided, running in case mode...");
            mode = Mode.CASE;

            if (sequenceDictionaryFile != null) {
                throw new UserException.BadInput("Invalid combination of inputs: Running in case mode, but a sequence dictionary was provided.");
            }

            if (intervalArgumentCollection.intervalsSpecified()) {
                throw new UserException.BadInput("Invalid combination of inputs: Running in case mode, but intervals were provided.");
            }

            if (inputAnnotatedIntervalsFile != null) {
                throw new UserException.BadInput("Invalid combination of inputs: Running in case mode, but annotated intervals were provided.");
            }

            Utils.nonNull(inputModelDir, "An input denoising-model directory must be provided in case mode.");

            intervalsFile = new File(inputModelDir, INPUT_MODEL_INTERVAL_FILE);             //in case mode, intervals are specified via a file in the input model directory
            IOUtils.canReadFile(intervalsFile);
            intervals = new LinkedHashSet<>(new SimpleIntervalCollection(intervalsFile).getIntervals());
        }

        Utils.nonNull(outputPrefix);
        Utils.validateArg(new File(inputContigPloidyCallsDir).exists(), String.format("Input contig-ploidy calls directory %s does not exist.", inputContigPloidyCallsDir));
        Utils.validateArg(new File(outputDir).exists(), String.format("Output directory %s does not exist.", outputDir));

        //TODO validate argument collections
    }

    private LinkedHashSet<SimpleInterval> getIntervalsFromFirstReadCountFile() {
        final File firstReadCountFile = inputReadCountFiles.get(0);
        logger.info(String.format("Retrieving intervals from first read-count file (%s)...", firstReadCountFile));
        final SimpleCountCollection readCounts = SimpleCountCollection.read(firstReadCountFile);
        return new LinkedHashSet<>(readCounts.getIntervals());
    }

    private List<File> writeIntervalSubsetReadCountFiles() {
        logger.info("Validating and aggregating metadata from input read-count files...");
        final int numSamples = inputReadCountFiles.size();
        final ListIterator<File> inputReadCountFilesIterator = inputReadCountFiles.listIterator();
        final List<File> intervalSubsetReadCountFiles = new ArrayList<>(numSamples);
        while (inputReadCountFilesIterator.hasNext()) {
            final int sampleIndex = inputReadCountFilesIterator.nextIndex();
            final File inputReadCountFile = inputReadCountFilesIterator.next();
            logger.info(String.format("Aggregating read-count file %s (%d / %d)", inputReadCountFile, sampleIndex + 1, numSamples));
            final SimpleCountCollection readCounts = SimpleCountCollection.read(inputReadCountFile);
            Utils.validateArg(new HashSet<>(readCounts.getIntervals()).containsAll(intervals),
                    String.format("Intervals for read-count file %s do not contain all specified intervals.", inputReadCountFile));
            final File intervalSubsetReadCountFile = IOUtils.createTempFile("sample-" + sampleIndex, ".tsv");
            new SimpleCountCollection(
                    readCounts.getSampleMetadata(),
                    readCounts.getRecords().stream()
                            .filter(c -> intervals.contains(c.getInterval()))
                            .collect(Collectors.toList())).write(intervalSubsetReadCountFile);
            intervalSubsetReadCountFiles.add(intervalSubsetReadCountFile);
        }
        return intervalSubsetReadCountFiles;
    }

    private boolean executeGermlineCNVCallerPythonScript(final List<File> intervalSubsetReadCountFiles) {
        final PythonScriptExecutor executor = new PythonScriptExecutor(true);
        final String outputDirArg = Utils.nonEmpty(outputDir).endsWith(File.separator) ? outputDir : outputDir + File.separator;    //add trailing slash if necessary

        //add required arguments
        final List<String> arguments = new ArrayList<>(Arrays.asList(
                "--ploidy_calls_path=" + inputContigPloidyCallsDir,
                "--output_calls_path=" + outputDirArg + outputPrefix + CALLS_PATH_SUFFIX));
        arguments.addAll(germlineDenoisingArgumentCollection.generatePythonArguments());
        arguments.addAll(germlineCallingArgumentCollection.generatePythonArguments());

        if (inputAnnotatedIntervalsFile != null) {
            arguments.add("--enable_explicit_gc_bias_modeling=True");
        }

        arguments.add("--read_count_tsv_files");
        arguments.addAll(intervalSubsetReadCountFiles.stream().map(File::getAbsolutePath).collect(Collectors.toList()));    //must follow addition of "--read_count_tsv_files"

        final String script;
        if (mode == Mode.COHORT) {
            script = COHORT_DENOISING_CALLING_PYTHON_SCRIPT;
            arguments.add("--modeling_interval_list=" + intervalsFile.getAbsolutePath());   //these are the annotated intervals, if provided
            arguments.add("--output_model_path=" + outputDirArg + outputPrefix + MODEL_PATH_SUFFIX);
            if (inputModelDir != null) {
                arguments.add("--input_model_path=" + inputModelDir);
            }
        } else {
            script = CASE_SAMPLE_CALLING_PYTHON_SCRIPT;
            arguments.add("--input_model_path=" + inputModelDir);
        }
        return executor.executeScript(
                new Resource(script, GermlineCNVCaller.class),
                null,
                arguments);
    }

    private enum GCExpectationMode {
        MAP("map"),
        EXACT("exact"),
        HYBRID("hybrid");

        final String pythonArgumentString;

        GCExpectationMode(final String pythonArgumentString) {
            this.pythonArgumentString = pythonArgumentString;
        }
    }

    private final class GermlineDenoisingArgumentCollection implements Serializable {
        private static final long serialVersionUID = 1L;

        @Argument(
                doc = "Maximum number of bias factors.",
                fullName = "maxBiasFactors",
                minValue = 0,
                optional = true
        )
        private int maxBiasFactors = 5;

        @Argument(
                doc = "Typical mapping error rate.",
                fullName = "mappingErrorRate",
                minValue = 0.,
                optional = true
        )
        private double mappingErrorRate = 0.01;

        @Argument(
                doc = "Typical scale of interval-specific unexplained variance.",
                fullName = "intervalPsiScale",
                minValue = 0.,
                optional = true
        )
        private double intervalPsiScale = 0.001;

        @Argument(
                doc = "Typical scale of sample-specific unexplained variance.",
                fullName = "samplePsiScale",
                minValue = 0.,
                optional = true
        )
        private double samplePsiScale = 0.0001;

        @Argument(
                doc = "Precision of read depth pinning to its global value.",
                fullName = "depthCorrectionTau",
                minValue = 0.,
                optional = true
        )
        private double depthCorrectionTau = 10000.0;

        @Argument(
                doc = "Standard deviation of log mean bias.",
                fullName = "logMeanBiasStandardDeviation",
                minValue = 0.,
                optional = true
        )
        private double logMeanBiasStandardDeviation = 0.1;

        @Argument(
                doc = "Initial value of ARD prior precision relative to the typical interval-specific unexplained variance scale.",
                fullName = "initARDRelUnexplainedVariance",
                minValue = 0.,
                optional = true
        )
        private double initARDRelUnexplainedVariance = 0.1;

        @Argument(
                doc = "Number of knobs on the GC curves.",
                fullName = "numGCBins",
                minValue = 1,
                optional = true
        )
        private int numGCBins = 20;

        @Argument(
                doc = "Prior standard deviation of the GC curve from flat.",
                fullName = "gcCurveStandardDeviation",
                minValue = 0.,
                optional = true
        )
        private double gcCurveStandardDeviation = 1.;

        @Argument(
                doc = "The strategy for calculating copy number posterior expectations in the denoising model.",
                fullName = "gcExpectationMode",
                optional = true
        )
        private GCExpectationMode gcExpectationMode = GCExpectationMode.HYBRID;

        @Argument(
                doc = "Enable discovery of bias factors.",
                fullName = "enableBiasFactors",
                optional = true
        )
        private boolean enableBiasFactors = true;

        @Argument(
                doc = "Disable bias factor discovery in intervals in CNV-active regions.",
                fullName = "disableBiasFactorsInFlatClass",
                optional = true
        )
        private boolean disableBiasFactorsInFlatClass = false;

        private List<String> generatePythonArguments() {
            final List<String> arguments = new ArrayList<>(Arrays.asList(
                    String.format("--mapping_error_rate=%f", mappingErrorRate),
                    String.format("--psi_t_scale=%f", intervalPsiScale),
                    String.format("--depth_correction_tau=%f", depthCorrectionTau),
                    String.format("--q_c_expectation_mode=%s", gcExpectationMode.pythonArgumentString)));
            if (mode == Mode.COHORT) {
                arguments.addAll(Arrays.asList(
                        String.format("--max_bias_factors=%d", maxBiasFactors),
                        String.format("--psi_s_scale=%f", samplePsiScale),
                        String.format("--log_mean_bias_std=%f", logMeanBiasStandardDeviation),
                        String.format("--init_ard_rel_unexplained_variance=%f", initARDRelUnexplainedVariance),
                        String.format("--num_gc_bins=%d", numGCBins),
                        String.format("--gc_curve_sd=%f", gcCurveStandardDeviation)));
                if (enableBiasFactors) {
                    arguments.add("--enable_bias_factors=True");
                }
                if (disableBiasFactorsInFlatClass) {
                    arguments.add("--disable_bias_factors_in_flat_class=True");
                }
            }
            return arguments;
        }
    }

    private final class GermlineCallingArgumentCollection implements Serializable {
        private static final long serialVersionUID = 1L;

        @Argument(
                doc = "Prior probability of alt copy number with respect to contig baseline state in the reference copy number.",
                fullName = "pAlt",
                minValue = 0.,
                optional = true
        )
        private double pAlt = 1E-6;

        @Argument(
                doc = "Prior probability of using flat copy number distribution as prior.",
                fullName = "pFlat",
                minValue = 0.,
                optional = true
        )
        private double pFlat = 1E-3;

        @Argument(
                doc = "Coherence length of CNV events (in the units of bp).",
                fullName = "cnvCoherenceLength",
                minValue = 0.,
                optional = true
        )
        private double cnvCoherenceLength = 10000.0;

        @Argument(
                doc = "Coherence length of copy number classes (in the units of bp).",
                fullName = "classCoherenceLength",
                minValue = 0.,
                optional = true
        )
        private double classCoherenceLength = 10000.0;

        @Argument(
                doc = "Highest considered copy number.",
                fullName = "maxCopyNumber",
                minValue = 0,
                optional = true
        )
        private int maxCopyNumber = 5;

        @Argument(
                doc = "Initialize with flat copy number prior everywhere.",
                fullName = "doInitializeToFlatClass",
                optional = true
        )
        private boolean doInitializeToFlatClass = true;

        private List<String> generatePythonArguments() {
            final List<String> arguments = new ArrayList<>(Arrays.asList(
                    String.format("--p_alt=%f", pAlt),
                    String.format("--cnv_coherence_length=%f", cnvCoherenceLength),
                    String.format("--max_copy_number=%d", maxCopyNumber)));
            if (mode == Mode.COHORT) {
                arguments.addAll(Arrays.asList(
                        String.format("--p_flat=%f", pFlat),
                        String.format("--class_coherence_length=%f", classCoherenceLength)));
                if (doInitializeToFlatClass) {
                    arguments.add("--initialize_to_flat_class=True");
                }
            }
            return arguments;
        }
    }
}
